#ifndef __WINTROSPECTION_EXT_H__
#define __WINTROSPECTION_EXT_H__
/*
 * DO NOT MODIFY. This file is automatically generated by scripts/apigen.py,
 * based on the <plugin>_int.h file in your plugin directory.
 *
 * Note: Function pointers for API calls are declared as extern.
 * The definition of the pointers is guarded by the PLUGIN_MAIN macro.
 * This plugin is defined only for the compilation unit matching the
 * name of the plugin.
 * This allows us to initialize API function pointers once, in the main
 * compilation unit, rather than in every compilation unit.
 */
#include <dlfcn.h>
#include "panda/plugin.h"

typedef char *(*make_pagedstr_t)(void);
extern make_pagedstr_t __make_pagedstr;
#ifdef PLUGIN_MAIN
make_pagedstr_t __make_pagedstr = NULL;
#endif
static inline char * make_pagedstr(void);
static inline char * make_pagedstr(void) {
    assert(__make_pagedstr);
    return __make_pagedstr();
}

typedef char *(*get_unicode_str_t)(CPUState *cpu, PTR ustr);
extern get_unicode_str_t __get_unicode_str;
#ifdef PLUGIN_MAIN
get_unicode_str_t __get_unicode_str = NULL;
#endif
static inline char * get_unicode_str(CPUState *cpu, PTR ustr);
static inline char * get_unicode_str(CPUState *cpu, PTR ustr) {
    assert(__get_unicode_str);
    return __get_unicode_str(cpu,ustr);
}

typedef uint32_t(*get_current_proc_t)(CPUState *cpu);
extern get_current_proc_t __get_current_proc;
#ifdef PLUGIN_MAIN
get_current_proc_t __get_current_proc = NULL;
#endif
static inline uint32_t get_current_proc(CPUState *cpu);
static inline uint32_t get_current_proc(CPUState *cpu) {
    assert(__get_current_proc);
    return __get_current_proc(cpu);
}

typedef PTR(*get_next_proc_t)(CPUState *cpu, PTR eproc);
extern get_next_proc_t __get_next_proc;
#ifdef PLUGIN_MAIN
get_next_proc_t __get_next_proc = NULL;
#endif
static inline PTR get_next_proc(CPUState *cpu, PTR eproc);
static inline PTR get_next_proc(CPUState *cpu, PTR eproc) {
    assert(__get_next_proc);
    return __get_next_proc(cpu,eproc);
}

typedef bool(*is_valid_process_t)(CPUState *cpu, PTR eproc);
extern is_valid_process_t __is_valid_process;
#ifdef PLUGIN_MAIN
is_valid_process_t __is_valid_process = NULL;
#endif
static inline bool is_valid_process(CPUState *cpu, PTR eproc);
static inline bool is_valid_process(CPUState *cpu, PTR eproc) {
    assert(__is_valid_process);
    return __is_valid_process(cpu,eproc);
}

typedef uint32_t(*get_pid_t)(CPUState *cpu, uint32_t eproc);
extern get_pid_t __get_pid;
#ifdef PLUGIN_MAIN
get_pid_t __get_pid = NULL;
#endif
static inline uint32_t get_pid(CPUState *cpu, uint32_t eproc);
static inline uint32_t get_pid(CPUState *cpu, uint32_t eproc) {
    assert(__get_pid);
    return __get_pid(cpu,eproc);
}

typedef PTR(*get_ppid_t)(CPUState *cpu, uint32_t eproc);
extern get_ppid_t __get_ppid;
#ifdef PLUGIN_MAIN
get_ppid_t __get_ppid = NULL;
#endif
static inline PTR get_ppid(CPUState *cpu, uint32_t eproc);
static inline PTR get_ppid(CPUState *cpu, uint32_t eproc) {
    assert(__get_ppid);
    return __get_ppid(cpu,eproc);
}

typedef PTR(*get_dtb_t)(CPUState *cpu, PTR eproc);
extern get_dtb_t __get_dtb;
#ifdef PLUGIN_MAIN
get_dtb_t __get_dtb = NULL;
#endif
static inline PTR get_dtb(CPUState *cpu, PTR eproc);
static inline PTR get_dtb(CPUState *cpu, PTR eproc) {
    assert(__get_dtb);
    return __get_dtb(cpu,eproc);
}

typedef void(*get_procname_t)(CPUState *cpu, uint32_t eproc, char **name);
extern get_procname_t __get_procname;
#ifdef PLUGIN_MAIN
get_procname_t __get_procname = NULL;
#endif
static inline void get_procname(CPUState *cpu, uint32_t eproc, char **name);
static inline void get_procname(CPUState *cpu, uint32_t eproc, char **name) {
    assert(__get_procname);
    return __get_procname(cpu,eproc,name);
}

typedef char *(*get_handle_object_name_t)(CPUState *cpu, HandleObject *ho);
extern get_handle_object_name_t __get_handle_object_name;
#ifdef PLUGIN_MAIN
get_handle_object_name_t __get_handle_object_name = NULL;
#endif
static inline char * get_handle_object_name(CPUState *cpu, HandleObject *ho);
static inline char * get_handle_object_name(CPUState *cpu, HandleObject *ho) {
    assert(__get_handle_object_name);
    return __get_handle_object_name(cpu,ho);
}

typedef int64_t(*get_file_handle_pos_t)(CPUState *cpu, uint32_t eproc, uint32_t handle);
extern get_file_handle_pos_t __get_file_handle_pos;
#ifdef PLUGIN_MAIN
get_file_handle_pos_t __get_file_handle_pos = NULL;
#endif
static inline int64_t get_file_handle_pos(CPUState *cpu, uint32_t eproc, uint32_t handle);
static inline int64_t get_file_handle_pos(CPUState *cpu, uint32_t eproc, uint32_t handle) {
    assert(__get_file_handle_pos);
    return __get_file_handle_pos(cpu,eproc,handle);
}

typedef char *(*get_handle_name_t)(CPUState *cpu, uint32_t eproc, uint32_t handle);
extern get_handle_name_t __get_handle_name;
#ifdef PLUGIN_MAIN
get_handle_name_t __get_handle_name = NULL;
#endif
static inline char * get_handle_name(CPUState *cpu, uint32_t eproc, uint32_t handle);
static inline char * get_handle_name(CPUState *cpu, uint32_t eproc, uint32_t handle) {
    assert(__get_handle_name);
    return __get_handle_name(cpu,eproc,handle);
}

typedef char *(*get_objname_t)(CPUState *cpu, uint32_t obj);
extern get_objname_t __get_objname;
#ifdef PLUGIN_MAIN
get_objname_t __get_objname = NULL;
#endif
static inline char * get_objname(CPUState *cpu, uint32_t obj);
static inline char * get_objname(CPUState *cpu, uint32_t obj) {
    assert(__get_objname);
    return __get_objname(cpu,obj);
}

typedef char *(*get_file_obj_name_t)(CPUState *cpu, uint32_t fobj);
extern get_file_obj_name_t __get_file_obj_name;
#ifdef PLUGIN_MAIN
get_file_obj_name_t __get_file_obj_name = NULL;
#endif
static inline char * get_file_obj_name(CPUState *cpu, uint32_t fobj);
static inline char * get_file_obj_name(CPUState *cpu, uint32_t fobj) {
    assert(__get_file_obj_name);
    return __get_file_obj_name(cpu,fobj);
}

typedef int64_t(*get_file_obj_pos_t)(CPUState *cpu, uint32_t fobj);
extern get_file_obj_pos_t __get_file_obj_pos;
#ifdef PLUGIN_MAIN
get_file_obj_pos_t __get_file_obj_pos = NULL;
#endif
static inline int64_t get_file_obj_pos(CPUState *cpu, uint32_t fobj);
static inline int64_t get_file_obj_pos(CPUState *cpu, uint32_t fobj) {
    assert(__get_file_obj_pos);
    return __get_file_obj_pos(cpu,fobj);
}

typedef char *(*read_unicode_string_t)(CPUState *cpu, uint32_t pUstr);
extern read_unicode_string_t __read_unicode_string;
#ifdef PLUGIN_MAIN
read_unicode_string_t __read_unicode_string = NULL;
#endif
static inline char * read_unicode_string(CPUState *cpu, uint32_t pUstr);
static inline char * read_unicode_string(CPUState *cpu, uint32_t pUstr) {
    assert(__read_unicode_string);
    return __read_unicode_string(cpu,pUstr);
}

typedef const char *(*get_mod_basename_t)(CPUState *cpu, PTR mod);
extern get_mod_basename_t __get_mod_basename;
#ifdef PLUGIN_MAIN
get_mod_basename_t __get_mod_basename = NULL;
#endif
static inline const char * get_mod_basename(CPUState *cpu, PTR mod);
static inline const char * get_mod_basename(CPUState *cpu, PTR mod) {
    assert(__get_mod_basename);
    return __get_mod_basename(cpu,mod);
}

typedef const char *(*get_mod_filename_t)(CPUState *cpu, PTR mod);
extern get_mod_filename_t __get_mod_filename;
#ifdef PLUGIN_MAIN
get_mod_filename_t __get_mod_filename = NULL;
#endif
static inline const char * get_mod_filename(CPUState *cpu, PTR mod);
static inline const char * get_mod_filename(CPUState *cpu, PTR mod) {
    assert(__get_mod_filename);
    return __get_mod_filename(cpu,mod);
}

typedef PTR(*get_mod_base_t)(CPUState *cpu, PTR mod);
extern get_mod_base_t __get_mod_base;
#ifdef PLUGIN_MAIN
get_mod_base_t __get_mod_base = NULL;
#endif
static inline PTR get_mod_base(CPUState *cpu, PTR mod);
static inline PTR get_mod_base(CPUState *cpu, PTR mod) {
    assert(__get_mod_base);
    return __get_mod_base(cpu,mod);
}

typedef PTR(*get_mod_size_t)(CPUState *cpu, PTR mod);
extern get_mod_size_t __get_mod_size;
#ifdef PLUGIN_MAIN
get_mod_size_t __get_mod_size = NULL;
#endif
static inline PTR get_mod_size(CPUState *cpu, PTR mod);
static inline PTR get_mod_size(CPUState *cpu, PTR mod) {
    assert(__get_mod_size);
    return __get_mod_size(cpu,mod);
}

typedef PTR(*get_next_mod_t)(CPUState *cpu, PTR mod);
extern get_next_mod_t __get_next_mod;
#ifdef PLUGIN_MAIN
get_next_mod_t __get_next_mod = NULL;
#endif
static inline PTR get_next_mod(CPUState *cpu, PTR mod);
static inline PTR get_next_mod(CPUState *cpu, PTR mod) {
    assert(__get_next_mod);
    return __get_next_mod(cpu,mod);
}

typedef void(*fill_osiproc_t)(CPUState *cpu, OsiProc *p, PTR eproc);
extern fill_osiproc_t __fill_osiproc;
#ifdef PLUGIN_MAIN
fill_osiproc_t __fill_osiproc = NULL;
#endif
static inline void fill_osiproc(CPUState *cpu, OsiProc *p, PTR eproc);
static inline void fill_osiproc(CPUState *cpu, OsiProc *p, PTR eproc) {
    assert(__fill_osiproc);
    return __fill_osiproc(cpu,p,eproc);
}

typedef void(*fill_osimod_t)(CPUState *cpu, OsiModule *m, PTR mod, bool ignore_basename);
extern fill_osimod_t __fill_osimod;
#ifdef PLUGIN_MAIN
fill_osimod_t __fill_osimod = NULL;
#endif
static inline void fill_osimod(CPUState *cpu, OsiModule *m, PTR mod, bool ignore_basename);
static inline void fill_osimod(CPUState *cpu, OsiModule *m, PTR mod, bool ignore_basename) {
    assert(__fill_osimod);
    return __fill_osimod(cpu,m,mod,ignore_basename);
}

typedef void(*add_mod_t)(CPUState *cpu, OsiModules *ms, PTR mod, bool ignore_basename);
extern add_mod_t __add_mod;
#ifdef PLUGIN_MAIN
add_mod_t __add_mod = NULL;
#endif
static inline void add_mod(CPUState *cpu, OsiModules *ms, PTR mod, bool ignore_basename);
static inline void add_mod(CPUState *cpu, OsiModules *ms, PTR mod, bool ignore_basename) {
    assert(__add_mod);
    return __add_mod(cpu,ms,mod,ignore_basename);
}

typedef void(*on_get_current_process_t)(CPUState *cpu, OsiProc **out_p);
extern on_get_current_process_t __on_get_current_process;
#ifdef PLUGIN_MAIN
on_get_current_process_t __on_get_current_process = NULL;
#endif
static inline void on_get_current_process(CPUState *cpu, OsiProc **out_p);
static inline void on_get_current_process(CPUState *cpu, OsiProc **out_p) {
    assert(__on_get_current_process);
    return __on_get_current_process(cpu,out_p);
}

typedef void(*on_get_processes_t)(CPUState *cpu, OsiProcs **out_ps);
extern on_get_processes_t __on_get_processes;
#ifdef PLUGIN_MAIN
on_get_processes_t __on_get_processes = NULL;
#endif
static inline void on_get_processes(CPUState *cpu, OsiProcs **out_ps);
static inline void on_get_processes(CPUState *cpu, OsiProcs **out_ps) {
    assert(__on_get_processes);
    return __on_get_processes(cpu,out_ps);
}

typedef uint32_t(*get_ntreadfile_esp_off_t)(void);
extern get_ntreadfile_esp_off_t __get_ntreadfile_esp_off;
#ifdef PLUGIN_MAIN
get_ntreadfile_esp_off_t __get_ntreadfile_esp_off = NULL;
#endif
static inline uint32_t get_ntreadfile_esp_off(void);
static inline uint32_t get_ntreadfile_esp_off(void) {
    assert(__get_ntreadfile_esp_off);
    return __get_ntreadfile_esp_off();
}

typedef uint32_t(*get_eproc_pid_off_t)(void);
extern get_eproc_pid_off_t __get_eproc_pid_off;
#ifdef PLUGIN_MAIN
get_eproc_pid_off_t __get_eproc_pid_off = NULL;
#endif
static inline uint32_t get_eproc_pid_off(void);
static inline uint32_t get_eproc_pid_off(void) {
    assert(__get_eproc_pid_off);
    return __get_eproc_pid_off();
}

typedef uint32_t(*get_eproc_name_off_t)(void);
extern get_eproc_name_off_t __get_eproc_name_off;
#ifdef PLUGIN_MAIN
get_eproc_name_off_t __get_eproc_name_off = NULL;
#endif
static inline uint32_t get_eproc_name_off(void);
static inline uint32_t get_eproc_name_off(void) {
    assert(__get_eproc_name_off);
    return __get_eproc_name_off();
}

typedef uint32_t(*get_kthread_kproc_off_t)(void);
extern get_kthread_kproc_off_t __get_kthread_kproc_off;
#ifdef PLUGIN_MAIN
get_kthread_kproc_off_t __get_kthread_kproc_off = NULL;
#endif
static inline uint32_t get_kthread_kproc_off(void);
static inline uint32_t get_kthread_kproc_off(void) {
    assert(__get_kthread_kproc_off);
    return __get_kthread_kproc_off();
}

typedef uint32_t(*get_eproc_objtable_off_t)(void);
extern get_eproc_objtable_off_t __get_eproc_objtable_off;
#ifdef PLUGIN_MAIN
get_eproc_objtable_off_t __get_eproc_objtable_off = NULL;
#endif
static inline uint32_t get_eproc_objtable_off(void);
static inline uint32_t get_eproc_objtable_off(void) {
    assert(__get_eproc_objtable_off);
    return __get_eproc_objtable_off();
}

typedef uint32_t(*get_obj_type_offset_t)(void);
extern get_obj_type_offset_t __get_obj_type_offset;
#ifdef PLUGIN_MAIN
get_obj_type_offset_t __get_obj_type_offset = NULL;
#endif
static inline uint32_t get_obj_type_offset(void);
static inline uint32_t get_obj_type_offset(void) {
    assert(__get_obj_type_offset);
    return __get_obj_type_offset();
}

typedef uint32_t(*handle_table_code_t)(CPUState *cpu, uint32_t table_vaddr);
extern handle_table_code_t __handle_table_code;
#ifdef PLUGIN_MAIN
handle_table_code_t __handle_table_code = NULL;
#endif
static inline uint32_t handle_table_code(CPUState *cpu, uint32_t table_vaddr);
static inline uint32_t handle_table_code(CPUState *cpu, uint32_t table_vaddr) {
    assert(__handle_table_code);
    return __handle_table_code(cpu,table_vaddr);
}

typedef uint32_t(*handle_table_L1_addr_t)(CPUState *cpu, uint32_t table_vaddr, uint32_t entry_num);
extern handle_table_L1_addr_t __handle_table_L1_addr;
#ifdef PLUGIN_MAIN
handle_table_L1_addr_t __handle_table_L1_addr = NULL;
#endif
static inline uint32_t handle_table_L1_addr(CPUState *cpu, uint32_t table_vaddr, uint32_t entry_num);
static inline uint32_t handle_table_L1_addr(CPUState *cpu, uint32_t table_vaddr, uint32_t entry_num) {
    assert(__handle_table_L1_addr);
    return __handle_table_L1_addr(cpu,table_vaddr,entry_num);
}

typedef uint32_t(*handle_table_L2_addr_t)(uint32_t L1_table, uint32_t L2);
extern handle_table_L2_addr_t __handle_table_L2_addr;
#ifdef PLUGIN_MAIN
handle_table_L2_addr_t __handle_table_L2_addr = NULL;
#endif
static inline uint32_t handle_table_L2_addr(uint32_t L1_table, uint32_t L2);
static inline uint32_t handle_table_L2_addr(uint32_t L1_table, uint32_t L2) {
    assert(__handle_table_L2_addr);
    return __handle_table_L2_addr(L1_table,L2);
}

typedef uint32_t(*handle_table_L1_entry_t)(CPUState *cpu, uint32_t table_vaddr, uint32_t entry_num);
extern handle_table_L1_entry_t __handle_table_L1_entry;
#ifdef PLUGIN_MAIN
handle_table_L1_entry_t __handle_table_L1_entry = NULL;
#endif
static inline uint32_t handle_table_L1_entry(CPUState *cpu, uint32_t table_vaddr, uint32_t entry_num);
static inline uint32_t handle_table_L1_entry(CPUState *cpu, uint32_t table_vaddr, uint32_t entry_num) {
    assert(__handle_table_L1_entry);
    return __handle_table_L1_entry(cpu,table_vaddr,entry_num);
}

typedef uint32_t(*handle_table_L2_entry_t)(uint32_t table_vaddr, uint32_t L1_table, uint32_t L2);
extern handle_table_L2_entry_t __handle_table_L2_entry;
#ifdef PLUGIN_MAIN
handle_table_L2_entry_t __handle_table_L2_entry = NULL;
#endif
static inline uint32_t handle_table_L2_entry(uint32_t table_vaddr, uint32_t L1_table, uint32_t L2);
static inline uint32_t handle_table_L2_entry(uint32_t table_vaddr, uint32_t L1_table, uint32_t L2) {
    assert(__handle_table_L2_entry);
    return __handle_table_L2_entry(table_vaddr,L1_table,L2);
}

typedef uint32_t(*handle_table_L3_entry_t)(uint32_t table_vaddr, uint32_t L2_table, uint32_t L3);
extern handle_table_L3_entry_t __handle_table_L3_entry;
#ifdef PLUGIN_MAIN
handle_table_L3_entry_t __handle_table_L3_entry = NULL;
#endif
static inline uint32_t handle_table_L3_entry(uint32_t table_vaddr, uint32_t L2_table, uint32_t L3);
static inline uint32_t handle_table_L3_entry(uint32_t table_vaddr, uint32_t L2_table, uint32_t L3) {
    assert(__handle_table_L3_entry);
    return __handle_table_L3_entry(table_vaddr,L2_table,L3);
}

bool init_wintrospection_api(void);

#ifdef PLUGIN_MAIN
#define API_PLUGIN_NAME "wintrospection"
#define IMPORT_PPP(module, func_name) { \
    __##func_name = (func_name##_t) dlsym(module, #func_name); \
    char *err = dlerror(); \
    if (err) { \
        printf("Couldn't find %s function in library %s.\n", #func_name, API_PLUGIN_NAME); \
        printf("Error: %s\n", err); \
        return false; \
    } \
}
bool init_wintrospection_api(void) {
    void *module = panda_get_plugin_by_name(API_PLUGIN_NAME);
    if (!module) {
        fprintf(stderr, "Couldn't load %s plugin: %s\n", API_PLUGIN_NAME, dlerror());
        return false;
    }
    IMPORT_PPP(module, make_pagedstr)
    IMPORT_PPP(module, get_unicode_str)
    IMPORT_PPP(module, get_current_proc)
    IMPORT_PPP(module, get_next_proc)
    IMPORT_PPP(module, is_valid_process)
    IMPORT_PPP(module, get_pid)
    IMPORT_PPP(module, get_ppid)
    IMPORT_PPP(module, get_dtb)
    IMPORT_PPP(module, get_procname)
    IMPORT_PPP(module, get_handle_object_name)
    IMPORT_PPP(module, get_file_handle_pos)
    IMPORT_PPP(module, get_handle_name)
    IMPORT_PPP(module, get_objname)
    IMPORT_PPP(module, get_file_obj_name)
    IMPORT_PPP(module, get_file_obj_pos)
    IMPORT_PPP(module, read_unicode_string)
    IMPORT_PPP(module, get_mod_basename)
    IMPORT_PPP(module, get_mod_filename)
    IMPORT_PPP(module, get_mod_base)
    IMPORT_PPP(module, get_mod_size)
    IMPORT_PPP(module, get_next_mod)
    IMPORT_PPP(module, fill_osiproc)
    IMPORT_PPP(module, fill_osimod)
    IMPORT_PPP(module, add_mod)
    IMPORT_PPP(module, on_get_current_process)
    IMPORT_PPP(module, on_get_processes)
    IMPORT_PPP(module, get_ntreadfile_esp_off)
    IMPORT_PPP(module, get_eproc_pid_off)
    IMPORT_PPP(module, get_eproc_name_off)
    IMPORT_PPP(module, get_kthread_kproc_off)
    IMPORT_PPP(module, get_eproc_objtable_off)
    IMPORT_PPP(module, get_obj_type_offset)
    IMPORT_PPP(module, handle_table_code)
    IMPORT_PPP(module, handle_table_L1_addr)
    IMPORT_PPP(module, handle_table_L2_addr)
    IMPORT_PPP(module, handle_table_L1_entry)
    IMPORT_PPP(module, handle_table_L2_entry)
    IMPORT_PPP(module, handle_table_L3_entry)
    return true;
}
#undef API_PLUGIN_NAME
#undef IMPORT_PPP
#endif

#endif
